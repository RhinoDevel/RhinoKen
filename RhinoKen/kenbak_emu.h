
// Marcel Timm, RhinoDevel, 2024may13

// KENBAK-1 emulator

// -----------------------------------------------------------------------------
//  7 6  5 4  3  2 1 0
//  O O  O O  O  O O O     Y              Y     C-o   Y            Y
//                                          LOCK UNL
// <2 1><4 2  1><4 2 1> -INPUT- ---ADDRESS--- ---MEMORY--- -----RUN---- ON
// <8 4  2 1><8  4 2 1>  CLEAR   DISPLAY SET   READ STORE   START STOP  U POWER
//  b b  b b  w  w w w     b        w     b     w     b       w    b    |
// -----------------------------------------------------------------------------
//
// O     = LED (white).
// 
// Y     = LED (yellow).
// 
// <...> = Number group.
// 
// b = Push button (black).
// 
// w = Push button (white).
// 
// C-o = 2-state toggle switch (horizontal).
// 
// U
// |   = 2-state toggle switch (vertical).

// SPEED OF OPERATION
// ------------------
//
// - Assuming the multivibrator gives a square wave of frequency ~1 MHz (this is
//   the signal CT), although some sources are a little bit unclear, they mix-up
//   CT and CP (e.g. see https://www.kenbak.com/design), let us trust the
//   recreated logic schematics found at
//   https://www.kenbak.com/footinycadschematics, where the inner resistors have
//   each a value of 270 Ohm and the capacitors a value of 1.5nF each which
//   leads to the frequency of CT being ~1 MHz.
//
// - The logic schematics page 01 shows that CT's frequency is divided by two
//   via a D flip flop, which causes CP to have half the frequency of CT,
//   which would be ~500 kHz.
//
// - One BIT time lasts for one cycle of signal CP, 1 / 500 kHz = 2 us.
//
// - One BYTE time lasts for eight BIT times, 8 x 2 us = 16 us.
//
// - Because of the delay line memory, most of the time the Kenbak-1 waits for
//   a wanted memory position to be found.
//   The tests seem to indicate that a Kenbak-1 would approximately do around
//   480 instructions per second (see https://www.kenbak.com/faqs).
//
// "SPEED" OF EMULATION
// --------------------
//
// - A step of this Kenbak-1 emulator equals processing ONE of the states
//   from the state diagrams (see pages 25, 26 and 27).
// 
//   This emulator does NOT simulate the delays caused by the serial memory
//   so let's assume 10 emulator steps per instruction (the emulator also does
//   not differentiate between run mode on and run mode off state steps..).
//
//   This would lead to 10 * 480 (emulator) steps per second (see above).
//   => 4800 steps / second.
//
// - If we want to update the output 25 times per second (to get 25 FPS),
//   for each update(/frame) we would take 4800 steps / 25 = 192 steps per
//   update.


// ^CP = Basic system clock (square wave), output of the clock pulse generator,
//       that has the RC multivibrator as input.

// 1 bit time = From one positive-to-ground transition to the next.

// 8 bit times exist: T0, T1, T2, T3, T4, T5, T6 and T7.
//                    Generated by the bit time register (a single bit shifts
//                    in that register), that has the clock pulse generator as
//                    input. Also known as bit time counter.

// 1 byte time = 8 bit times, from T0 to the start of the next T0.

// ^C7 is a 1/2 bit time long (clock) pulse at the second half of T7.

// Two delay lines (shift registers) exist as memory (instead of RAM).
// Delay line 0 = bytes 0 to 127, delay line 1 = bytes 128 to 255.
// JDL0 = input of delay line 0, JSL1 = input of delay line 1.
// DL0 = output of delay line 0, DL1 = output of delay line 1.

// A7 = Most significant address bit, selects delay line (0 or 1).
// A0 to A6 select a position / address / time slot.

// L = Memory address register. Shifts serially, increases by 1 for each byte
//     time.
//     Is, in effect, one byte ahead of the memory.
//     Read serially via L0.

// R = Serial signal, "holds" the address for read or write.
//     When R0 to R6 equal L0 to L6, the data for the desired address will be at
//     the input and output of the memory at NEXT byte time.
//     R7 is used to determine A7 (delay line select signal).
// ^R = Desired address in logic complement form.

// A comparator compares L and R, the result is signal CM, ONLY VALID during T7.
// If CM is true, comparison of address exists, otherwise not.

// NEXT: Page 20.

// Signals:
//
// A  = One of the two inputs to the adder/subtractor, see also B. (20)
// A7 = The most significant address bit which selects one of the two delay
//      lines which constitute the memory. (03)
// B  = One of the two inputs to the adder/subtractor. During subtraction B is
//      subtracted from A. (20).
// ...
// CM = The comparison between the memory address register and the desired
//      address is true. CM is only valid during T7. (02)
// ...
// ^DA = Display address (from push button of that name). Goes to ground when
//       button is pushed. (04)
// ^DD = Display data (from read memory push button) after being cleaned up.
//       Goes to ground when button is pushed. (04)
// DEX = Index address mode.
// ...
// ^EA = Enter Address (from set address push button) after being cleaned up.
//       Goes to ground when button is pushed. (04)
// ED = Automatic processing should end after the current instruction is
//      finished. (22)
// ^EN = Enter data (from store memory push button) after being cleaned up. Goes
//       to ground when button is pushed. (04)
// ...
// ^GO = Signal from start push button after being cleaned up. Goes to ground
//       when button is pushed. (04)
// ...
// IN = True during byte time when location 377 (input) is being read from
//      memory. (04)
// IND = Indirect address mode.
// I0/I7 = Generally the I register is the instruction register. I7 is the most
//         significant bit. As an instruction register, I holds the first byte
//         of an instruction. (14)
// J = Any jump instruction See also JD, JI, JM, JP.
// JC = Jump conditions are true; the jump should be made. (21)
// JD = A jump instruction wth direct addressing mode (not indirect).
// ...
// JI = A jump instruction with indirect addressing.
// ...
// K0/K7 = The K register controls the data lamps. K7 is the most significant
//         bit. (07)
// ...
// ^R = Desired address in logic complement form. (03)
// ...
// MR = Memory read. Is the output of DL0 or DL1 as selected by A7. (03)
// ...
// PF = Four is to be added to the P register. (22)
// PO = One is to be added to the P register. (22)
// PT = Two is to be added to the P register. (22)
// ...
// TM = A transfer to memory, i.e., a store A, B, or X instruction.
// ...
// WD = Write data. Data to be written in the memory. (23)
// ...
// W0/W7 = W register. W0 is least significant bit. A general utility register.
//         (17)

// Additional signals:
//
// X5 = EN or DA or DD (see page 25).

#ifndef KENBAK_EMU
#define KENBAK_EMU

#include "kenbak_data.h"

void kenbak_emu_init_input(
    struct kenbak_data* const d, bool const keep_switch_power_on);

void kenbak_emu_delete(struct kenbak_data * const d);

int kenbak_emu_step(struct kenbak_data * const d);

struct kenbak_data * kenbak_emu_create(bool const randomize_memory);

#endif //KENBAK_EMU
